--[[
    HELL HUB - COMBAT WARRIORS
    Auto Parry Script with Hell Hub UI
    Developer: fabi3c
]]

-- SCRIPT PROTECTION - Only runs when loaded through key system
local function verifyAuth()
    if not getgenv or not getgenv().HellHubAuth then
        print("[Hell Hub] No auth found")
        return false
    end
    local auth = getgenv().HellHubAuth
    if not auth.Verified then
        print("[Hell Hub] Not verified")
        return false
    end
    print("[Hell Hub] Auth OK! UserKey:", auth.UserKey)
    return true
end

if not verifyAuth() then
    warn("[Hell Hub] Unauthorized access! Please use the key system.")
    return
end

-- Save user's key before clearing auth
local UserEnteredKey = getgenv().HellHubAuth.UserKey
getgenv().HellHubAuth = nil -- Clear token after verification

-- Real-time key validation (checks GitHub every 10 seconds)
local KeyValidationURL = "https://raw.githubusercontent.com/elpingus/hell-hub/refs/heads/main/valid-key.txt"
local keyCheckRunning = true
task.spawn(function()
    print("[Hell Hub] Key validation started. Your key:", UserEnteredKey)
    task.wait(5) -- Wait 5 seconds before first check
    while keyCheckRunning do
        local success, result = pcall(function()
            -- Add random param to bypass cache
            local noCacheURL = KeyValidationURL .. "?nocache=" .. tostring(os.time())
            local currentValidKey = game:HttpGet(noCacheURL)
            if currentValidKey then
                currentValidKey = currentValidKey:gsub("%s+", "") -- Remove whitespace
                print("[Hell Hub] Current valid key:", currentValidKey, "| Your key:", UserEnteredKey)
                if currentValidKey ~= "" and currentValidKey ~= UserEnteredKey then
                    -- Key has changed on GitHub, kick user
                    print("[Hell Hub] KEY MISMATCH! Kicking user...")
                    keyCheckRunning = false
                    pcall(function()
                        -- Show warning notification if Library exists
                        if Library and Library.notification then
                            Library:notification{
                                Title = "Key Expired",
                                Text = "Your key has been revoked. Please get a new key!",
                                Duration = 5
                            }
                        end
                    end)
                    task.wait(2)
                    -- Destroy all Hell Hub GUIs
                    for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
                        pcall(function()
                            if gui.Name:find("Hell") or gui.Name:find("ESP") or gui.Name:find("Crosshair") then
                                gui:Destroy()
                            end
                        end)
                    end
                end
            end
        end)
        if not success then
            print("[Hell Hub] Validation error:", result)
        end
        if keyCheckRunning then
            task.wait(10) -- Check every 10 seconds
        end
    end
end)

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- SETTINGS
local Settings = {
    autoParry = false,
    autoKick = false,
    rageParry = false,
    parryRange = 18,
    minDelay = 50,
    maxDelay = 120,
    missChance = 12,
    parryCooldown = 0.3,
    predictSwing = false,
    soundParry = false,
    targetPriority = false,
    noParryCooldown = false,
    antiRagdoll = false,
    infiniteStamina = false,
    noJumpCooldown = false,
    noDashCooldown = false,
    noFallDamage = false,
    speedBoost = false,
    jumpBoost = false,
    customSpeed = 16,
    customJump = 50,
    -- ESP
    espEnabled = false,
    espName = false,
    espDistance = false,
    espHealth = false,
    espParryCount = false,
    espTextSize = 14,
    -- ESP Colors
    espNameColor = Color3.fromRGB(255, 255, 255),
    espDistanceColor = Color3.fromRGB(200, 200, 200),
    espHealthColor = Color3.fromRGB(100, 255, 100),
    espParryColor = Color3.fromRGB(255, 200, 100),
    -- ESP Positions (Y offset from top)
    espNameOffset = 0,
    espDistanceOffset = 18,
    espHealthOffset = 32,
    espParryOffset = 46,
}

-- ESP DATA
local ESPObjects = {}
local ParryStats = {}

-- ANTI-CHEAT BYPASS SYSTEM
local bypassEnabled = true
local blockedRemotes = {
    "AntiCheat", "AC", "Detect", "Detection", "Check", "Verify",
    "Report", "Ban", "Kick", "Flag", "Suspicious", "Exploit",
    "Cheat", "Hack", "Speed", "Teleport", "Fly", "Noclip",
    "WalkSpeed", "JumpPower", "Stamina", "Analytics", "Log"
}

local spoofedProperties = {
    WalkSpeed = 16,
    JumpPower = 50,
    JumpHeight = 7.2,
    Health = 100,
    MaxHealth = 100
}

pcall(function()
    local mt = getrawmetatable(game)
    if mt and setreadonly then
        setreadonly(mt, false)
        
        local oldNamecall = mt.__namecall
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            local selfName = tostring(self):lower()
            
            if method == "FireServer" or method == "InvokeServer" then
                for _, blocked in pairs(blockedRemotes) do
                    if selfName:find(blocked:lower()) then
                        return nil
                    end
                end
                
                for i, arg in pairs(args) do
                    if type(arg) == "string" then
                        local argLower = arg:lower()
                        for _, blocked in pairs(blockedRemotes) do
                            if argLower:find(blocked:lower()) then
                                return nil
                            end
                        end
                    end
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        local oldIndex = mt.__index
        mt.__index = newcclosure(function(self, key)
            if bypassEnabled and self:IsA("Humanoid") then
                if spoofedProperties[key] then
                    return spoofedProperties[key]
                end
            end
            return oldIndex(self, key)
        end)
        
        local oldNewindex = mt.__newindex
        mt.__newindex = newcclosure(function(self, key, value)
            if bypassEnabled and self:IsA("Humanoid") then
                if key == "WalkSpeed" and Settings.speedBoost then
                    return oldNewindex(self, key, Settings.customSpeed)
                end
                if key == "JumpPower" and Settings.jumpBoost then
                    return oldNewindex(self, key, Settings.customJump)
                end
            end
            return oldNewindex(self, key, value)
        end)
        
        setreadonly(mt, true)
    end
end)

task.spawn(function()
    while task.wait(1) do
        pcall(function()
            for _, v in pairs(game:GetService("ReplicatedStorage"):GetDescendants()) do
                local name = v.Name:lower()
                for _, blocked in pairs(blockedRemotes) do
                    if name:find(blocked:lower()) and (v:IsA("RemoteEvent") or v:IsA("RemoteFunction")) then
                        pcall(function()
                            v.OnClientInvoke = function() return nil end
                        end)
                    end
                end
            end
        end)
    end
end)

-- LOAD HELL HUB LIBRARY
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/elpingus/hell-hub/refs/heads/main/hellhub.lua"))()

-- CREATE WINDOW
local Window = Library:create{
    Name = "Hell Hub - Combat Warriors",
    Size = UDim2.fromOffset(580, 400),
    Theme = Library.Themes.Dark,
    ToggleKey = Enum.KeyCode.Insert
}

local CombatTab = Window:tab{
    Name = "Combat",
    Icon = "rbxassetid://6034287594"
}

local hitboxEnabled = false
local hitboxSize = 15
local killAuraEnabled = false
local killAuraRange = 15
local autoGloryEnabled = false
local ghostModeEnabled = false
local ghostYOffset = -15
local originalHitboxes = {}
local spawnedDummy = nil

local function spawnTestRagdoll()
    if spawnedDummy then
        pcall(function() spawnedDummy:Destroy() end)
        spawnedDummy = nil
    end
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    local dummy = Instance.new("Model")
    dummy.Name = "TestDummy"
    
    local torso = Instance.new("Part")
    torso.Name = "Torso"
    torso.Size = Vector3.new(2, 2, 1)
    torso.CFrame = myRoot.CFrame * CFrame.new(0, 0, -8)
    torso.Anchored = false
    torso.CanCollide = true
    torso.BrickColor = BrickColor.new("Bright blue")
    torso.Parent = dummy
    
    local head = Instance.new("Part")
    head.Name = "Head"
    head.Size = Vector3.new(2, 1, 1)
    head.CFrame = torso.CFrame * CFrame.new(0, 1.5, 0)
    head.Anchored = false
    head.CanCollide = true
    head.BrickColor = BrickColor.new("Bright yellow")
    head.Parent = dummy
    
    local face = Instance.new("Decal")
    face.Name = "face"
    face.Texture = "rbxasset://textures/face.png"
    face.Face = Enum.NormalId.Front
    face.Parent = head
    
    local headMesh = Instance.new("SpecialMesh")
    headMesh.MeshType = Enum.MeshType.Head
    headMesh.Scale = Vector3.new(1.25, 1.25, 1.25)
    headMesh.Parent = head
    
    local leftArm = Instance.new("Part")
    leftArm.Name = "Left Arm"
    leftArm.Size = Vector3.new(1, 2, 1)
    leftArm.CFrame = torso.CFrame * CFrame.new(-1.5, 0, 0)
    leftArm.Anchored = false
    leftArm.CanCollide = true
    leftArm.BrickColor = BrickColor.new("Bright yellow")
    leftArm.Parent = dummy
    
    local rightArm = Instance.new("Part")
    rightArm.Name = "Right Arm"
    rightArm.Size = Vector3.new(1, 2, 1)
    rightArm.CFrame = torso.CFrame * CFrame.new(1.5, 0, 0)
    rightArm.Anchored = false
    rightArm.CanCollide = true
    rightArm.BrickColor = BrickColor.new("Bright yellow")
    rightArm.Parent = dummy
    
    local leftLeg = Instance.new("Part")
    leftLeg.Name = "Left Leg"
    leftLeg.Size = Vector3.new(1, 2, 1)
    leftLeg.CFrame = torso.CFrame * CFrame.new(-0.5, -2, 0)
    leftLeg.Anchored = false
    leftLeg.CanCollide = true
    leftLeg.BrickColor = BrickColor.new("Br. yellowish green")
    leftLeg.Parent = dummy
    
    local rightLeg = Instance.new("Part")
    rightLeg.Name = "Right Leg"
    rightLeg.Size = Vector3.new(1, 2, 1)
    rightLeg.CFrame = torso.CFrame * CFrame.new(0.5, -2, 0)
    rightLeg.Anchored = false
    rightLeg.CanCollide = true
    rightLeg.BrickColor = BrickColor.new("Br. yellowish green")
    rightLeg.Parent = dummy
    
    local root = Instance.new("Part")
    root.Name = "HumanoidRootPart"
    root.Size = Vector3.new(2, 2, 1)
    root.CFrame = torso.CFrame
    root.Anchored = true
    root.CanCollide = false
    root.Transparency = 1
    root.Parent = dummy
    
    local function weld(p0, p1, c0)
        local w = Instance.new("Weld")
        w.Part0 = p0
        w.Part1 = p1
        w.C0 = c0
        w.Parent = p0
    end
    
    weld(root, torso, CFrame.new())
    weld(torso, head, CFrame.new(0, 1.5, 0))
    weld(torso, leftArm, CFrame.new(-1.5, 0, 0))
    weld(torso, rightArm, CFrame.new(1.5, 0, 0))
    weld(torso, leftLeg, CFrame.new(-0.5, -2, 0))
    weld(torso, rightLeg, CFrame.new(0.5, -2, 0))
    
    local hum = Instance.new("Humanoid")
    hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
    hum.HealthDisplayDistance = 100
    hum.NameDisplayDistance = 100
    hum.MaxHealth = 100
    hum.Health = 100
    hum.Parent = dummy
    
    dummy.PrimaryPart = root
    dummy.Parent = workspace
    spawnedDummy = dummy
end

local function destroyTestRagdoll()
    if spawnedDummy then
        pcall(function() spawnedDummy:Destroy() end)
        spawnedDummy = nil
    end
end

local function getEnemies()
    local enemies = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local hum = player.Character:FindFirstChild("Humanoid")
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if hum and root and hum.Health > 0 then
                table.insert(enemies, {Player = player, Character = player.Character, Humanoid = hum, Root = root})
            end
        end
    end
    if spawnedDummy then
        local dummyHum = spawnedDummy:FindFirstChild("Humanoid")
        local dummyRoot = spawnedDummy:FindFirstChild("HumanoidRootPart")
        if dummyHum and dummyRoot then
            table.insert(enemies, {Player = nil, Character = spawnedDummy, Humanoid = dummyHum, Root = dummyRoot})
        end
    end
    return enemies
end

local function getDownedEnemies()
    local downed = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local hum = player.Character:FindFirstChild("Humanoid")
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if hum and root then
                local isDowned = hum:GetState() == Enum.HumanoidStateType.Physics or hum:GetState() == Enum.HumanoidStateType.Ragdoll or hum.Health <= 0
                if not isDowned then
                    for _, v in pairs(player.Character:GetDescendants()) do
                        if v:IsA("BoolValue") and (v.Name == "Downed" or v.Name == "IsDown" or v.Name == "KO") and v.Value == true then
                            isDowned = true
                            break
                        end
                    end
                end
                if isDowned then
                    table.insert(downed, {Player = player, Character = player.Character, Root = root})
                end
            end
        end
    end
    return downed
end

local function expandHitbox(character, size)
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and (part.Name == "Head" or part.Name == "UpperTorso" or part.Name == "HumanoidRootPart") then
            if not originalHitboxes[part] then
                originalHitboxes[part] = part.Size
            end
            part.Size = Vector3.new(size, size, size)
            part.Transparency = 0.7
            part.CanCollide = false
        end
    end
end

local function resetHitbox(character)
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and originalHitboxes[part] then
            part.Size = originalHitboxes[part]
            part.Transparency = 0
            originalHitboxes[part] = nil
        end
    end
end

task.spawn(function()
    while task.wait(0.1) do
        if hitboxEnabled then
            pcall(function()
                for _, enemy in pairs(getEnemies()) do
                    expandHitbox(enemy.Character, hitboxSize)
                end
            end)
        end
    end
end)

task.spawn(function()
    local vim = game:GetService("VirtualInputManager")
    while true do
        task.wait(0.12 + math.random() * 0.08)
        if killAuraEnabled then
            pcall(function()
                local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if myRoot then
                    for _, enemy in pairs(getEnemies()) do
                        local dist = (myRoot.Position - enemy.Root.Position).Magnitude
                        if dist <= killAuraRange then
                            vim:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                            task.wait(0.02 + math.random() * 0.03)
                            vim:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                            break
                        end
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    local vim = game:GetService("VirtualInputManager")
    while true do
        task.wait(0.18 + math.random() * 0.1)
        if autoGloryEnabled then
            pcall(function()
                local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if myRoot then
                    local downed = getDownedEnemies()
                    for _, enemy in pairs(downed) do
                        local dist = (myRoot.Position - enemy.Root.Position).Magnitude
                        if dist <= 20 then
                            vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                            task.wait(0.05 + math.random() * 0.05)
                            vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                            break
                        end
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(0.04 + math.random() * 0.02)
        if ghostModeEnabled then
            pcall(function()
                local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if root then
                    root.CFrame = root.CFrame * CFrame.new(0, ghostYOffset * 0.1, 0)
                end
            end)
        end
    end
end)

CombatTab:button{ Name = "Spawn Test Dummy", Description = "Spawn a local dummy for testing", Callback = spawnTestRagdoll }
CombatTab:button{ Name = "Remove Test Dummy", Description = "Remove the spawned dummy", Callback = destroyTestRagdoll }

CombatTab:toggle{ Name = "Hitbox Expander", Description = "Expand enemy hitboxes", StartingState = false, Callback = function(s) 
    hitboxEnabled = s 
    if not s then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                resetHitbox(player.Character)
            end
        end
        if spawnedDummy then resetHitbox(spawnedDummy) end
    end
end }
CombatTab:slider{ Name = "Hitbox Size", Description = "Size of expanded hitbox", Min = 5, Max = 30, Default = 15, Callback = function(v) hitboxSize = v end }

CombatTab:toggle{ Name = "Kill Aura", Description = "Auto attack nearby enemies", StartingState = false, Callback = function(s) killAuraEnabled = s end }
CombatTab:slider{ Name = "Kill Aura Range", Description = "Attack range", Min = 5, Max = 30, Default = 15, Callback = function(v) killAuraRange = v end }

CombatTab:toggle{ Name = "Auto Glory Kill", Description = "Auto finish downed enemies", StartingState = false, Callback = function(s) autoGloryEnabled = s end }

CombatTab:toggle{ Name = "Ghost Mode", Description = "Go underground for farming", StartingState = false, Callback = function(s) ghostModeEnabled = s end }
CombatTab:slider{ Name = "Ghost Depth", Description = "How deep underground", Min = -50, Max = 0, Default = -15, Callback = function(v) ghostYOffset = v end }

local spinBotEnabled = false
local spinSpeed = 15
local blinkEnabled = false
local blinkDistance = 20

game:GetService("RunService").Heartbeat:Connect(function()
    if spinBotEnabled then
        pcall(function()
            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(spinSpeed * 0.5), 0)
            end
        end)
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if blinkEnabled and input.KeyCode == Enum.KeyCode.C then
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local look = workspace.CurrentCamera.CFrame.LookVector
            root.CFrame = root.CFrame + (look * blinkDistance)
        end
    end
end)

task.spawn(function()
    while task.wait(0.1) do
        if Settings.noParryCooldown then
            for i, v in pairs(getgc(true)) do
                if type(v) == "table" then
                    if rawget(v, "PARRY_COOLDOWN") then
                        v.PARRY_COOLDOWN = 0.1
                    end
                    if rawget(v, "getParryCooldown") then
                        v.getParryCooldown = function() return 0.1 end
                    end
                end
            end
        end
    end
end)

CombatTab:toggle{ Name = "Spin Bot", Description = "360 derece donerek vur", StartingState = false, Callback = function(s) spinBotEnabled = s end }
CombatTab:slider{ Name = "Spin Speed", Description = "Donme hizi", Min = 5, Max = 50, Default = 15, Callback = function(v) spinSpeed = v end }

CombatTab:toggle{ Name = "Blink (C Tusu)", Description = "C'ye bas, baktigin yone isinlan", StartingState = false, Callback = function(s) blinkEnabled = s end }
CombatTab:slider{ Name = "Blink Distance", Description = "Isinlanma mesafesi", Min = 5, Max = 50, Default = 20, Callback = function(v) blinkDistance = v end }

CombatTab:toggle{ Name = "No Parry Cooldown", Description = "Parry bekleme suresini kaldir", StartingState = false, Callback = function(s) Settings.noParryCooldown = s end }

-- PARRY TAB (Shield Emoji)
-----------------------------------------------------------------
local ParryTab = Window:tab{
    Name = "Parry",
    Icon = "rbxassetid://8569322835"
}

-- Main Toggles
ParryTab:toggle{
    Name = "Auto Parry",
    Description = "Automatically parry incoming attacks",
    StartingState = false,
    Callback = function(state)
        Settings.autoParry = state
        Library:set_status(state and "Auto Parry Active" or "Idle")
    end
}

ParryTab:toggle{
    Name = "Auto Kick",
    Description = "Automatically kick after successful parry",
    StartingState = false,
    Callback = function(state)
        Settings.autoKick = state
    end
}

ParryTab:toggle{
    Name = "Rage Parry",
    Description = "No cooldown, no miss chance - INSTANT parry spam",
    StartingState = false,
    Callback = function(state)
        Settings.rageParry = state
        if state then
            Settings.missChance = 0
            Settings.parryCooldown = 0
            Settings.minDelay = 0
            Settings.maxDelay = 10
        end
        Library:set_status(state and "RAGE MODE ACTIVE" or "Idle")
    end
}

ParryTab:toggle{
    Name = "Predict Swing",
    Description = "Predict enemy attacks before they swing",
    StartingState = false,
    Callback = function(state)
        Settings.predictSwing = state
    end
}

ParryTab:toggle{
    Name = "Sound Detection",
    Description = "Use sound (hitbox creation) to detect attacks (Hybrid Mode)",
    StartingState = false,
    Callback = function(state)
        Settings.soundParry = state
    end
}

ParryTab:toggle{
    Name = "Target Priority",
    Description = "Prioritize enemies with weapons",
    StartingState = false,
    Callback = function(state)
        Settings.targetPriority = state
    end
}

-- Parry Settings Section
local ParrySettings = ParryTab:section{
    Name = "Parry Settings"
}

ParrySettings:slider{
    Name = "Parry Range",
    Description = "Detection range (studs)",
    Min = 10,
    Max = 30,
    Default = 18,
    Callback = function(val)
        Settings.parryRange = val
    end
}

ParrySettings:slider{
    Name = "Min Delay (ms)",
    Description = "Minimum reaction delay",
    Min = 20,
    Max = 100,
    Default = 50,
    Callback = function(val)
        Settings.minDelay = val
    end
}

ParrySettings:slider{
    Name = "Max Delay (ms)",
    Description = "Maximum reaction delay",
    Min = 50,
    Max = 200,
    Default = 120,
    Callback = function(val)
        Settings.maxDelay = val
    end
}

ParrySettings:slider{
    Name = "Miss Chance %",
    Description = "Chance to miss (legit)",
    Min = 0,
    Max = 30,
    Default = 12,
    Callback = function(val)
        Settings.missChance = val
    end
}

ParrySettings:slider{
    Name = "Cooldown (ms)",
    Description = "Cooldown between parries",
    Min = 100,
    Max = 500,
    Default = 300,
    Callback = function(val)
        Settings.parryCooldown = val / 1000
    end
}

-----------------------------------------------------------------
-- ESP TAB
-----------------------------------------------------------------
local ESPTab = Window:tab{
    Name = "ESP",
    Icon = "rbxassetid://8594150191"
}

ESPTab:toggle{
    Name = "ESP Enabled",
    Description = "Enable player ESP",
    StartingState = false,
    Callback = function(state)
        Settings.espEnabled = state
        if not state then
            for _, esp in pairs(ESPObjects) do
                if esp.BillboardGui then
                    esp.BillboardGui:Destroy()
                end
            end
            ESPObjects = {}
        end
    end
}

-- ESP Elements Section
local ESPElements = ESPTab:section{
    Name = "ESP Elements"
}

ESPElements:toggle{
    Name = "Show Name",
    Description = "Player display name",
    StartingState = true,
    Callback = function(state)
        Settings.espName = state
    end
}

ESPElements:toggle{
    Name = "Show Distance",
    Description = "Distance in studs",
    StartingState = true,
    Callback = function(state)
        Settings.espDistance = state
    end
}

ESPElements:toggle{
    Name = "Show Health",
    Description = "Player health bar",
    StartingState = true,
    Callback = function(state)
        Settings.espHealth = state
    end
}

ESPElements:toggle{
    Name = "Show Parry Count",
    Description = "How many times you parried",
    StartingState = false,
    Callback = function(state)
        Settings.espParryCount = state
    end
}

-- ESP Colors Section
local ESPColors = ESPTab:section{
    Name = "ESP Colors"
}

ESPColors:color_picker{
    Name = "Name Color",
    Description = "Color for player names",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(color)
        Settings.espNameColor = color
        -- Update existing ESP
        for _, esp in pairs(ESPObjects) do
            if esp.NameLabel then
                esp.NameLabel.TextColor3 = color
            end
        end
    end
}

ESPColors:color_picker{
    Name = "Distance Color",
    Description = "Color for distance text",
    Default = Color3.fromRGB(200, 200, 200),
    Callback = function(color)
        Settings.espDistanceColor = color
        for _, esp in pairs(ESPObjects) do
            if esp.DistanceLabel then
                esp.DistanceLabel.TextColor3 = color
            end
        end
    end
}

ESPColors:color_picker{
    Name = "Health Color",
    Description = "Color for health text",
    Default = Color3.fromRGB(100, 255, 100),
    Callback = function(color)
        Settings.espHealthColor = color
    end
}

ESPColors:color_picker{
    Name = "Parry Count Color",
    Description = "Color for parry count",
    Default = Color3.fromRGB(255, 200, 100),
    Callback = function(color)
        Settings.espParryColor = color
        for _, esp in pairs(ESPObjects) do
            if esp.ParryLabel then
                esp.ParryLabel.TextColor3 = color
            end
        end
    end
}

-- ESP Size Section
local ESPSize = ESPTab:section{
    Name = "ESP Size"
}

ESPSize:slider{
    Name = "Text Size",
    Description = "Size of ESP text",
    Min = 10,
    Max = 24,
    Default = 14,
    Callback = function(val)
        Settings.espTextSize = val
        -- Update existing ESP
        for _, esp in pairs(ESPObjects) do
            if esp.NameLabel then esp.NameLabel.TextSize = val end
            if esp.DistanceLabel then esp.DistanceLabel.TextSize = val - 2 end
            if esp.HealthLabel then esp.HealthLabel.TextSize = val - 2 end
            if esp.ParryLabel then esp.ParryLabel.TextSize = val - 2 end
        end
    end
}

-- ========== FLOATING ESP WINDOW ==========
-- Create the floating ESP preview window (appears when ESP is enabled)
local espWindow = Library:esp_window{
    Title = "ESP Preview - Combat Warriors",
    Position = UDim2.new(0, 650, 0.5, -225),
    Elements = {
        {name = "Name", category = "Main", color = Settings.espNameColor, enabled = Settings.espName, side = "top"},
        {name = "Health Bar", category = "Main", color = Settings.espHealthColor, enabled = Settings.espHealth, side = "left"},
        {name = "Distance", category = "Main", color = Settings.espDistanceColor, enabled = Settings.espDistance, side = "left"},
        {name = "Weapon", category = "Item", color = Color3.fromRGB(255, 200, 100), enabled = true, side = "bottom"},
        {name = "Parry Count", category = "Combat", color = Settings.espParryColor, enabled = Settings.espParryCount, side = "right"},
    },
    OnElementToggle = function(name, enabled)
        if name == "Name" then Settings.espName = enabled
        elseif name == "Health Bar" then Settings.espHealth = enabled
        elseif name == "Distance" then Settings.espDistance = enabled
        elseif name == "Parry Count" then Settings.espParryCount = enabled
        end
    end
}

-- Initially hide the window
espWindow:Hide()

-- Show/Hide window when ESP is toggled (update the ESP Enabled toggle callback)
local originalEspCallback = Settings.espEnabled
ESPTab:button{
    Name = "Open ESP Preview",
    Description = "Open floating ESP layout editor",
    Callback = function()
        espWindow:Toggle()
    end
}

-----------------------------------------------------------------
-- MISC TAB
-----------------------------------------------------------------
local MiscTab = Window:tab{
    Name = "Misc",
    Icon = "rbxassetid://8569329416"
}

-- Global Stamina Controller Reference
local StaminaController = nil

-- [SECURITY] Anti-Cheat Bypass (HookMetaMethod)
local oldNameCall = nil
local oldNewIndex = nil
local startBypass = false

-- Safe Reference to Remotes (for blocking)
local bannedRemotes = {
    "FallDamage", -- Common name, verify if specific to CW
    "Damage",
    "SelfDamage"
}

-- Initialize Hooks once
local function initHooks()
    if startBypass then return end
    startBypass = true
    
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    
    -- Hook __namecall (Event Firing)
    oldNameCall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if Settings.noFallDamage and method == "FireServer" then
             -- Block known fall damage remotes
             for _, name in pairs(bannedRemotes) do
                 if tostring(self) == name then
                     return nil
                 end
             end
        end
        
        return oldNameCall(self, unpack(args))
    end))
    
    -- Hook __newindex (Property Setting)
    oldNewIndex = hookmetamethod(game, "__newindex", newcclosure(function(self, key, value)
        -- Bypass WalkSpeed/JumpPower detections that try to reset it
        if Settings.speedBoost and key == "WalkSpeed" and self:IsA("Humanoid") then
             if value ~= Settings.customSpeed then
                 return oldNewIndex(self, key, Settings.customSpeed) 
             end
        end
        
        if Settings.jumpBoost and key == "JumpPower" and self:IsA("Humanoid") then
             if value ~= Settings.customJump then
                 return oldNewIndex(self, key, Settings.customJump)
             end
        end
        
        return oldNewIndex(self, key, value)
    end))
    
    setreadonly(mt, true)
end
task.spawn(initHooks)

-- [FUNCTION] Advanced GC-Based Features (Stealth Mode)
local function updateAdvancedMisc()
    if not (Settings.infiniteStamina or Settings.noJumpCooldown or Settings.noDashCooldown) then return end
    
    for i, v in pairs(getgc(true)) do
        if type(v) == "table" then
            -- 1. Infinite Stamina (Aggressive Spam Method - Restored)
            if Settings.infiniteStamina then
                if rawget(v, "_setStamina") or rawget(v, "_stamina") then
                     if rawget(v, "_setStamina") then
                        v._setStamina = function(self, val)
                            self._stamina = math.huge
                            if self._staminaChangedSignal then 
                                self._staminaChangedSignal:Fire(100) 
                            end
                        end
                    end
                    
                    -- Spawn aggressive loop for THIS specific table
                    task.spawn(function()
                        while Settings.infiniteStamina do
                            v._stamina = math.huge
                            if v._staminaChangedSignal then 
                                v._staminaChangedSignal:Fire(100) 
                            end
                            task.wait()
                        end
                    end)
                end
            end
            
            -- 2. No Jump Cooldown (Stealth - Reduced Delay)
            if Settings.noJumpCooldown then
                -- Do NOT hook getCanJump (High Detection Risk)
                -- Instead, reduce the cooldown to a "Legit Fast" value (0.08s)
                -- 0.0s is flagged as "Impossible", 0.08s is just "Good Timing"
                if rawget(v, "JUMP_DELAY_ADD") then 
                    v.JUMP_DELAY_ADD = 0.08 
                end
            end

            -- 3. No Dash Cooldown (Stealth Hook)
            if Settings.noDashCooldown then
                if rawget(v, "getDashCooldown") then 
                    v.getDashCooldown = function() return 0 end 
                end
                -- Don't set DASH_COOLDOWN constant to 0, just hook the getter
            end
        end
    end
end

-- Re-scan on respawn
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if Settings.infiniteStamina or Settings.noJumpCooldown or Settings.noDashCooldown then
        task.spawn(updateAdvancedMisc)
    end
end)

-- [LOGIC] Fly System
local flying = false
local flySpeed = 50
local bodyGyro, bodyVel

local function startFly()
    if flying then return end
    flying = true
    local char = LocalPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local hum = char and char:FindFirstChild("Humanoid")
    if not root or not hum then return end
    
    bodyGyro = Instance.new("BodyGyro", root)
    bodyGyro.P = 9e4
    bodyGyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.cframe = root.CFrame
    bodyVel = Instance.new("BodyVelocity", root)
    bodyVel.velocity = Vector3.new(0, 0, 0)
    bodyVel.maxForce = Vector3.new(9e9, 9e9, 9e9)
    hum.PlatformStand = true
    
    task.spawn(function()
        while flying and root and hum and hum.Health > 0 do
            local cam = workspace.CurrentCamera
            if not cam then break end
            bodyGyro.cframe = cam.CFrame
            local vel = Vector3.new(0, 0, 0)
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.W) then vel = vel + cam.CFrame.LookVector * flySpeed end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.S) then vel = vel - cam.CFrame.LookVector * flySpeed end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.A) then vel = vel - cam.CFrame.RightVector * flySpeed end
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.D) then vel = vel + cam.CFrame.RightVector * flySpeed end
            bodyVel.velocity = vel
            task.wait()
        end
        stopFly()
    end)
end

function stopFly()
    flying = false
    if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
    if bodyVel then bodyVel:Destroy() bodyVel = nil end
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.PlatformStand = false
    end
end

-- [LOGIC] Super Jump
local superJumpEnabled = false
game:GetService("UserInputService").InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Y then if flying then stopFly() else startFly() end end
    if input.KeyCode == Enum.KeyCode.LeftAlt and superJumpEnabled then
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then root.Velocity = Vector3.new(root.Velocity.X, 150, root.Velocity.Z) end
    end
end)

-- [LOOP] Optimized Combined RenderStepped (Safe Logic)
local velocitySpeedEnabled = false
local velocitySpeedVal = 1

game:GetService("RunService").RenderStepped:Connect(function(dt)
    if not LocalPlayer.Character then return end
    local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hum or not root then return end
    
    -- 1. JumpPower Enforce (via MetaHook now, but fallback here)
    if Settings.jumpBoost and hum.JumpPower ~= Settings.customJump then
        hum.JumpPower = Settings.customJump
    end
    
    -- 2. No Fall Damage (State Logic - Reduced Spam)
    if Settings.noFallDamage then
        -- Only force if actually falling to reduce detection noise
        local state = hum:GetState()
        if state == Enum.HumanoidStateType.FallingDown or state == Enum.HumanoidStateType.Freefall then
            hum:ChangeState(Enum.HumanoidStateType.Running)
        end
    end
    
    -- 3. Stamina Force (Attribute Logic - Aggressive)
    if Settings.infiniteStamina then
        -- Force to true infinity (Working method)
        if LocalPlayer.Character:GetAttribute("Stamina") then
            LocalPlayer.Character:SetAttribute("Stamina", math.huge) 
        end
    end
    
    -- 4. Speed (Velocity Based - Safe)
    if velocitySpeedEnabled then
        if hum.MoveDirection.Magnitude > 0 then
            local look = workspace.CurrentCamera.CFrame.LookVector
            look = Vector3.new(look.X, 0, look.Z).Unit
            local moveDir = hum.MoveDirection
            
            root.AssemblyLinearVelocity = Vector3.new(
                moveDir.X * (16 * velocitySpeedVal * 3), 
                root.AssemblyLinearVelocity.Y, 
                moveDir.Z * (16 * velocitySpeedVal * 3)
            )
        end
    end
end)

-- [LOOP] Optimized Low-Frequency Loop (0.5s)
local autoReviveEnabled = false
local autoRespawnEnabled = false
local vim = game:GetService("VirtualInputManager")

-- [LOOP] Optimized Low-Frequency Loop (0.5s)
local autoReviveEnabled = false
-- Removed Auto Respawn & Walk on Water as requested

task.spawn(function()
    while task.wait(0.5) do
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        
        -- Anti-Freeze / Unanchor (Safety Check)
        if root and root.Anchored and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0 then
            -- Safe unanchor: only if strictly necessary
            root.Anchored = false
        end
        
        -- Auto Self Revive (Death Screen Button)
        if autoReviveEnabled then
            local pGui = LocalPlayer:FindFirstChild("PlayerGui")
            if pGui then
                local death = pGui:FindFirstChild("DeathScreen") or pGui:FindFirstChild("DeathUI")
                if death then
                     local btn = death:FindFirstChild("Revive", true) or death:FindFirstChild("ReviveButton", true)
                     if btn and btn:IsA("GuiButton") then
                          for _, c in pairs(getconnections(btn.MouseButton1Click)) do 
                               -- pcall to prevent errors being logged
                               pcall(function() c:Fire() end) 
                          end
                     end
                end
            end
        end
    end
end)

-- [UI] Features List
MiscTab:toggle{ Name = "Fly (Press Y)", Description = "Flight Mode", StartingState = false, Callback = function(s) if s then startFly() else stopFly() end end }
MiscTab:slider{ Name = "Fly Speed", Description = "", Min = 20, Max = 200, Default = 50, Callback = function(v) flySpeed = v end }

MiscTab:toggle{ Name = "Super Jump (Left Alt)", Description = "Launch Upwards", StartingState = false, Callback = function(s) superJumpEnabled = s end }

MiscTab:toggle{ Name = "Speed", Description = "Velocity Based (Safe)", StartingState = false, Callback = function(s) velocitySpeedEnabled = s end }
MiscTab:slider{ Name = "Speed Value", Description = "Multiplier", Min = 0, Max = 3, Default = 1, Callback = function(v) velocitySpeedVal = v end }

MiscTab:toggle{ Name = "Jump Boost", Description = "Custom JumpPower", StartingState = false, Callback = function(s) Settings.jumpBoost = s end }
MiscTab:slider{ Name = "Jump Power", Description = "", Min = 50, Max = 200, Default = 70, Callback = function(v) Settings.customJump = v end }

MiscTab:toggle{ Name = "Infinite Stamina", Description = "Spam Full Stamina", StartingState = false, Callback = function(s) Settings.infiniteStamina = s if s then task.spawn(updateAdvancedMisc) end end }
MiscTab:toggle{ Name = "No Jump Cooldown", Description = "Remove BHop Delay", StartingState = false, Callback = function(s) Settings.noJumpCooldown = s if s then task.spawn(updateAdvancedMisc) end end }
MiscTab:toggle{ Name = "No Dash Cooldown", Description = "Remove Dash Delay", StartingState = false, Callback = function(s) Settings.noDashCooldown = s if s then task.spawn(updateAdvancedMisc) end end }
MiscTab:toggle{ Name = "No Fall Damage", Description = "Prevent Fall Damage", StartingState = false, Callback = function(s) Settings.noFallDamage = s end }
MiscTab:toggle{ Name = "Auto Self Revive", Description = "Auto Click Revive", StartingState = false, Callback = function(s) autoReviveEnabled = s end }





-----------------------------------------------------------------
-- PLAYER TAB (Updated)
-----------------------------------------------------------------
local PlayerTab = Window:tab{
    Name = "Player",
    Icon = "rbxassetid://8577523456"
}

PlayerTab:toggle{
    Name = "Anti Ragdoll",
    Description = "Prevent character from ragdolling",
    StartingState = false,
    Callback = function(state)
        Settings.antiRagdoll = state
    end
}

PlayerTab:button{
    Name = "Reset Character",
    Description = "Respawn your character",
    Callback = function()
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then
            hum.Health = 0
        end
    end
}

PlayerTab:button{
    Name = "Reset Parry Stats",
    Description = "Reset all parry statistics",
    Callback = function()
        ParryStats = {}
        parryCount = 0
        comboCount = 0
        parryCountLabel:SetDescription("0")
        comboCountLabel:SetDescription("0")
    end
}

-----------------------------------------------------------------
-- INFO TAB
-----------------------------------------------------------------
local InfoTab = Window:tab{
    Name = "Info",
    Icon = "rbxassetid://8628681683"
}

InfoTab:label{
    Text = "Hell Hub",
    Description = "Combat Warriors Edition v1.0"
}

InfoTab:label{
    Text = "Player",
    Description = LocalPlayer.Name
}

local statusLabel = InfoTab:label{
    Text = "Auto Parry Status",
    Description = "OFF"
}

local parryCountLabel = InfoTab:label{
    Text = "Total Parries",
    Description = "0"
}

local comboCountLabel = InfoTab:label{
    Text = "Current Combo",
    Description = "0"
}

-----------------------------------------------------------------
-- ESP SYSTEM
-----------------------------------------------------------------
local function createESP(player)
    if player == LocalPlayer then return end
    if ESPObjects[player] then return end
    
    local character = player.Character
    if not character then return end
    
    local head = character:FindFirstChild("Head")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not head or not hrp then return end
    
    local topBillboard = Instance.new("BillboardGui")
    topBillboard.Name = "HellHubESP_Top"
    topBillboard.Adornee = head
    topBillboard.Size = UDim2.new(0, 150, 0, 50)
    topBillboard.StudsOffset = Vector3.new(0, 2, 0)
    topBillboard.AlwaysOnTop = true
    topBillboard.Parent = game:GetService("CoreGui")
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "Name"
    nameLabel.Size = UDim2.new(1, 0, 0, 18)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = Settings.espNameColor
    nameLabel.TextStrokeTransparency = 0.3
    nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextSize = Settings.espTextSize
    nameLabel.Text = player.DisplayName
    nameLabel.Parent = topBillboard
    
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Name = "Distance"
    distanceLabel.Size = UDim2.new(1, 0, 0, 14)
    distanceLabel.Position = UDim2.new(0, 0, 0, 18)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.TextColor3 = Settings.espDistanceColor
    distanceLabel.TextStrokeTransparency = 0.3
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.TextSize = Settings.espTextSize - 2
    distanceLabel.Text = "0m"
    distanceLabel.Parent = topBillboard
    
    local sideBillboard = Instance.new("BillboardGui")
    sideBillboard.Name = "HellHubESP_Side"
    sideBillboard.Adornee = hrp
    sideBillboard.Size = UDim2.new(0, 30, 0, 80)
    sideBillboard.StudsOffset = Vector3.new(-2.5, 0, 0)
    sideBillboard.AlwaysOnTop = true
    sideBillboard.Parent = game:GetService("CoreGui")
    
    local healthNum = Instance.new("TextLabel")
    healthNum.Name = "HealthNum"
    healthNum.Size = UDim2.new(1, 0, 0, 16)
    healthNum.Position = UDim2.new(0, 0, 0.5, -48)
    healthNum.BackgroundTransparency = 1
    healthNum.TextColor3 = Color3.fromRGB(255, 255, 255)
    healthNum.TextStrokeTransparency = 0.3
    healthNum.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    healthNum.Font = Enum.Font.GothamBold
    healthNum.TextSize = 14
    healthNum.Text = "100"
    healthNum.Parent = sideBillboard
    
    local healthBarBG = Instance.new("Frame")
    healthBarBG.Name = "HealthBarBG"
    healthBarBG.Size = UDim2.new(0, 6, 0, 70)
    healthBarBG.Position = UDim2.new(0.5, -3, 0.5, -30)
    healthBarBG.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    healthBarBG.BorderColor3 = Color3.fromRGB(0, 0, 0)
    healthBarBG.BorderSizePixel = 1
    healthBarBG.Parent = sideBillboard
    
    local healthBarFill = Instance.new("Frame")
    healthBarFill.Name = "Fill"
    healthBarFill.Size = UDim2.new(1, 0, 1, 0)
    healthBarFill.Position = UDim2.new(0, 0, 0, 0)
    healthBarFill.AnchorPoint = Vector2.new(0, 1)
    healthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    healthBarFill.BorderSizePixel = 0
    healthBarFill.Parent = healthBarBG
    
    local bottomBillboard = Instance.new("BillboardGui")
    bottomBillboard.Name = "HellHubESP_Bottom"
    bottomBillboard.Adornee = hrp
    bottomBillboard.Size = UDim2.new(0, 150, 0, 30)
    bottomBillboard.StudsOffset = Vector3.new(0, -3.5, 0)
    bottomBillboard.AlwaysOnTop = true
    bottomBillboard.Parent = game:GetService("CoreGui")
    
    local weaponLabel = Instance.new("TextLabel")
    weaponLabel.Name = "Weapon"
    weaponLabel.Size = UDim2.new(1, 0, 1, 0)
    weaponLabel.BackgroundTransparency = 1
    weaponLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
    weaponLabel.TextStrokeTransparency = 0.3
    weaponLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    weaponLabel.Font = Enum.Font.GothamBold
    weaponLabel.TextSize = 12
    weaponLabel.Text = ""
    weaponLabel.Parent = bottomBillboard
    
    ESPObjects[player] = {
        TopBillboard = topBillboard,
        SideBillboard = sideBillboard,
        BottomBillboard = bottomBillboard,
        NameLabel = nameLabel,
        DistanceLabel = distanceLabel,
        HealthNum = healthNum,
        HealthBarBG = healthBarBG,
        HealthBarFill = healthBarFill,
        WeaponLabel = weaponLabel
    }
end

local function updateESP()
    if not Settings.espEnabled then return end
    
    local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if not ESPObjects[player] then
                createESP(player)
            end
            
            local esp = ESPObjects[player]
            if esp and esp.TopBillboard then
                local head = player.Character:FindFirstChild("Head")
                local hum = player.Character:FindFirstChild("Humanoid")
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                
                if head and hum and hrp and myHRP then
                    esp.TopBillboard.Adornee = head
                    if esp.SideBillboard then esp.SideBillboard.Adornee = hrp end
                    if esp.BottomBillboard then esp.BottomBillboard.Adornee = hrp end
                    
                    esp.NameLabel.Visible = Settings.espName
                    
                    if Settings.espDistance then
                        local dist = math.floor((myHRP.Position - hrp.Position).Magnitude)
                        esp.DistanceLabel.Text = dist .. "m"
                        esp.DistanceLabel.Visible = true
                    else
                        esp.DistanceLabel.Visible = false
                    end
                    
                    if Settings.espHealth then
                        local health = math.floor(hum.Health)
                        local maxHealth = hum.MaxHealth
                        local ratio = math.clamp(health / maxHealth, 0, 1)
                        
                        if esp.HealthNum then
                            esp.HealthNum.Text = tostring(health)
                            esp.HealthNum.Visible = true
                        end
                        
                        if esp.SideBillboard then
                            esp.SideBillboard.Enabled = true
                        end
                        
                        if esp.HealthBarFill then
                            esp.HealthBarFill.Size = UDim2.new(1, 0, ratio, 0)
                            esp.HealthBarFill.Position = UDim2.new(0, 0, 1, 0)
                            esp.HealthBarFill.BackgroundColor3 = Color3.fromRGB(255 * (1 - ratio), 255 * ratio, 50)
                        end
                    else
                        if esp.SideBillboard then esp.SideBillboard.Enabled = false end
                    end
                    
                    if esp.WeaponLabel and esp.BottomBillboard then
                        local tool = player.Character:FindFirstChildOfClass("Tool")
                        if tool then
                            esp.WeaponLabel.Text = tool.Name
                            esp.BottomBillboard.Enabled = true
                        else
                            esp.WeaponLabel.Text = ""
                            esp.BottomBillboard.Enabled = false
                        end
                    end
                end
            end
        end
    end
    
    if spawnedDummy then
        local dummyKey = "TestDummy"
        if not ESPObjects[dummyKey] then
            local head = spawnedDummy:FindFirstChild("Head")
            local hrp = spawnedDummy:FindFirstChild("HumanoidRootPart") or spawnedDummy:FindFirstChild("Torso")
            if head and hrp then
                local topBillboard = Instance.new("BillboardGui")
                topBillboard.Name = "HellHubESP_Dummy_Top"
                topBillboard.Adornee = head
                topBillboard.Size = UDim2.new(0, 150, 0, 50)
                topBillboard.StudsOffset = Vector3.new(0, 2, 0)
                topBillboard.AlwaysOnTop = true
                topBillboard.Parent = game:GetService("CoreGui")
                
                local nameLabel = Instance.new("TextLabel")
                nameLabel.Name = "Name"
                nameLabel.Size = UDim2.new(1, 0, 0, 18)
                nameLabel.Position = UDim2.new(0, 0, 0, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                nameLabel.TextStrokeTransparency = 0.3
                nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
                nameLabel.Font = Enum.Font.GothamBold
                nameLabel.TextSize = Settings.espTextSize
                nameLabel.Text = "[TEST DUMMY]"
                nameLabel.Parent = topBillboard
                
                local distanceLabel = Instance.new("TextLabel")
                distanceLabel.Name = "Distance"
                distanceLabel.Size = UDim2.new(1, 0, 0, 14)
                distanceLabel.Position = UDim2.new(0, 0, 0, 18)
                distanceLabel.BackgroundTransparency = 1
                distanceLabel.TextColor3 = Settings.espDistanceColor
                distanceLabel.TextStrokeTransparency = 0.3
                distanceLabel.Font = Enum.Font.Gotham
                distanceLabel.TextSize = Settings.espTextSize - 2
                distanceLabel.Text = "0m"
                distanceLabel.Parent = topBillboard
                
                local sideBillboard = Instance.new("BillboardGui")
                sideBillboard.Name = "HellHubESP_Dummy_Side"
                sideBillboard.Adornee = hrp
                sideBillboard.Size = UDim2.new(0, 30, 0, 80)
                sideBillboard.StudsOffset = Vector3.new(-2.5, 0, 0)
                sideBillboard.AlwaysOnTop = true
                sideBillboard.Parent = game:GetService("CoreGui")
                
                local healthNum = Instance.new("TextLabel")
                healthNum.Name = "HealthNum"
                healthNum.Size = UDim2.new(1, 0, 0, 16)
                healthNum.Position = UDim2.new(0, 0, 0.5, -48)
                healthNum.BackgroundTransparency = 1
                healthNum.TextColor3 = Color3.fromRGB(255, 255, 255)
                healthNum.TextStrokeTransparency = 0.3
                healthNum.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
                healthNum.Font = Enum.Font.GothamBold
                healthNum.TextSize = 14
                healthNum.Text = "100"
                healthNum.Parent = sideBillboard
                
                local healthBarBG = Instance.new("Frame")
                healthBarBG.Name = "HealthBarBG"
                healthBarBG.Size = UDim2.new(0, 6, 0, 70)
                healthBarBG.Position = UDim2.new(0.5, -3, 0.5, -30)
                healthBarBG.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                healthBarBG.BorderColor3 = Color3.fromRGB(0, 0, 0)
                healthBarBG.BorderSizePixel = 1
                healthBarBG.Parent = sideBillboard
                
                local healthBarFill = Instance.new("Frame")
                healthBarFill.Name = "Fill"
                healthBarFill.Size = UDim2.new(1, 0, 1, 0)
                healthBarFill.Position = UDim2.new(0, 0, 1, 0)
                healthBarFill.AnchorPoint = Vector2.new(0, 1)
                healthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                healthBarFill.BorderSizePixel = 0
                healthBarFill.Parent = healthBarBG
                
                ESPObjects[dummyKey] = {
                    TopBillboard = topBillboard,
                    SideBillboard = sideBillboard,
                    BottomBillboard = nil,
                    NameLabel = nameLabel,
                    DistanceLabel = distanceLabel,
                    HealthNum = healthNum,
                    HealthBarBG = healthBarBG,
                    HealthBarFill = healthBarFill,
                    WeaponLabel = nil
                }
            end
        end
        
        local esp = ESPObjects[dummyKey]
        if esp and esp.TopBillboard then
            local head = spawnedDummy:FindFirstChild("Head")
            local hum = spawnedDummy:FindFirstChild("Humanoid")
            local hrp = spawnedDummy:FindFirstChild("HumanoidRootPart") or spawnedDummy:FindFirstChild("Torso")
            
            if head and hum and hrp and myHRP then
                esp.TopBillboard.Adornee = head
                if esp.SideBillboard then esp.SideBillboard.Adornee = hrp end
                
                esp.NameLabel.Visible = Settings.espName
                
                if Settings.espDistance then
                    local dist = math.floor((myHRP.Position - hrp.Position).Magnitude)
                    esp.DistanceLabel.Text = dist .. "m"
                    esp.DistanceLabel.Visible = true
                else
                    esp.DistanceLabel.Visible = false
                end
                
                if Settings.espHealth then
                    local health = math.floor(hum.Health)
                    local maxHealth = hum.MaxHealth
                    local ratio = math.clamp(health / maxHealth, 0, 1)
                    
                    if esp.HealthNum then
                        esp.HealthNum.Text = tostring(health)
                        esp.HealthNum.Visible = true
                    end
                    
                    if esp.SideBillboard then
                        esp.SideBillboard.Enabled = true
                    end
                    
                    if esp.HealthBarFill then
                        esp.HealthBarFill.Size = UDim2.new(1, 0, ratio, 0)
                        esp.HealthBarFill.BackgroundColor3 = Color3.fromRGB(255 * (1 - ratio), 255 * ratio, 50)
                    end
                else
                    if esp.SideBillboard then esp.SideBillboard.Enabled = false end
                end
            end
        end
    else
        local dummyKey = "TestDummy"
        if ESPObjects[dummyKey] then
            if ESPObjects[dummyKey].TopBillboard then ESPObjects[dummyKey].TopBillboard:Destroy() end
            if ESPObjects[dummyKey].SideBillboard then ESPObjects[dummyKey].SideBillboard:Destroy() end
            if ESPObjects[dummyKey].BottomBillboard then ESPObjects[dummyKey].BottomBillboard:Destroy() end
            ESPObjects[dummyKey] = nil
        end
    end
    
    for player, esp in pairs(ESPObjects) do
        if type(player) ~= "string" and (not player or not player.Parent) then
            if esp.TopBillboard then esp.TopBillboard:Destroy() end
            if esp.SideBillboard then esp.SideBillboard:Destroy() end
            if esp.BottomBillboard then esp.BottomBillboard:Destroy() end
            ESPObjects[player] = nil
        end
    end
end

Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        if ESPObjects[player].TopBillboard then ESPObjects[player].TopBillboard:Destroy() end
        if ESPObjects[player].SideBillboard then ESPObjects[player].SideBillboard:Destroy() end
        if ESPObjects[player].BottomBillboard then ESPObjects[player].BottomBillboard:Destroy() end
        ESPObjects[player] = nil
    end
end)

-----------------------------------------------------------------
-- PARRY LOGIC
-----------------------------------------------------------------
local lastParry = 0
local parryCount = 0
local comboCount = 0
local lastTarget = nil

local function getChar()
    return LocalPlayer.Character
end

local function getHRP()
    local c = getChar()
    return c and c:FindFirstChild("HumanoidRootPart")
end

local function getHum()
    local c = getChar()
    return c and c:FindFirstChild("Humanoid")
end

local function gaussRand(min, max)
    local u1, u2 = math.random(), math.random()
    if u1 < 0.0001 then u1 = 0.0001 end
    local z = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
    return math.clamp((min + max) / 2 + z * (max - min) / 4, min, max)
end
-- ================================================
-- ADVANCED PARRY DETECTION SYSTEM v3.0
-- Based on research: Speed, Position, Angle, Distance prediction
-- Uses raycast + animation + prediction
-- ================================================

-- Track enemy attack states
local EnemyAttackStates = {}

-- Combat Warriors swing speeds (frames)
local SWING_TIMING = {
    light = 0.25,  -- Light attack ~0.25s
    heavy = 0.45,  -- Heavy attack ~0.45s
    combo = 0.3,   -- Combo attack ~0.3s
    default = 0.3  -- Default timing
}

-- Setup animation tracking for each player
local function setupAnimationTracking(player)
    if player == LocalPlayer then return end
    if EnemyAttackStates[player] then return end
    
    EnemyAttackStates[player] = {
        isAttacking = false,
        attackStartTime = 0,
        lastAnimName = "",
        attackType = "light",
        swingDirection = Vector3.zero,
    }
    
    local function hookAnimator(animator, char)
        animator.AnimationPlayed:Connect(function(track)
            local name = string.lower(track.Name)
            
            -- Attack patterns
            local isAttack = name:find("swing") or name:find("slash") or 
                            name:find("m1") or name:find("attack") or
                            name:find("combo") or name:find("light") or
                            name:find("heavy") or name:find("stab") or
                            name:find("cut") or name:find("strike") or
                            name:find("chop") or name:find("slice")
            
            -- Exclude non-attacks
            local isNotAttack = name:find("walk") or name:find("run") or 
                               name:find("idle") or name:find("jump") or
                               name:find("fall") or name:find("climb") or
                               name:find("equip") or name:find("hold") or
                               name:find("block") or name:find("parry") or
                               name:find("dodge") or name:find("roll")
            
            if isAttack and not isNotAttack then
                local state = EnemyAttackStates[player]
                if state then
                    state.isAttacking = true
                    state.attackStartTime = tick()
                    state.lastAnimName = name
                    
                    -- Determine attack type
                    if name:find("heavy") then
                        state.attackType = "heavy"
                    elseif name:find("combo") then
                        state.attackType = "combo"
                    else
                        state.attackType = "light"
                    end
                    
                    -- Calculate swing direction
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        state.swingDirection = hrp.CFrame.LookVector
                    end
                end
            end
            
            track.Stopped:Connect(function()
                local state = EnemyAttackStates[player]
                if state then
                    state.isAttacking = false
                end
            end)
        end)
    end
    
    -- Watch for character changes
    player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        local hum = char:FindFirstChild("Humanoid")
        if hum then
            local animator = hum:FindFirstChildOfClass("Animator")
            if animator then
                hookAnimator(animator, char)
            end
        end
    end)
    
    -- Initialize for current character
    if player.Character then
        local hum = player.Character:FindFirstChild("Humanoid")
        if hum then
            local animator = hum:FindFirstChildOfClass("Animator")
            if animator then
                hookAnimator(animator, player.Character)
            end
        end
    end
end

-- Setup tracking for all players
for _, player in pairs(Players:GetPlayers()) do
    task.spawn(function()
        setupAnimationTracking(player)
    end)
end
Players.PlayerAdded:Connect(setupAnimationTracking)
Players.PlayerRemoving:Connect(function(player)
    EnemyAttackStates[player] = nil
end)

-- Calculate if weapon will hit us based on trajectory
local function willWeaponHitUs(targetChar, myHRP)
    local tool = targetChar:FindFirstChildOfClass("Tool")
    if not tool then return false, 0 end
    
    local handle = tool:FindFirstChild("Handle") or tool:FindFirstChild("Blade") or tool:FindFirstChild("HitBox")
    if not handle or not handle:IsA("BasePart") then return false, 0 end
    
    local weaponPos = handle.Position
    local weaponVel = handle.Velocity
    local myPos = myHRP.Position
    
    -- Distance to weapon
    local distance = (myPos - weaponPos).Magnitude
    
    -- Direction from weapon to us
    local directionToUs = (myPos - weaponPos).Unit
    
    -- Velocity component towards us
    local velocityTowardsUs = weaponVel:Dot(directionToUs)
    
    -- Time until impact (if weapon continues current trajectory)
    local timeToImpact = distance / math.max(velocityTowardsUs, 1)
    
    -- Weapon is coming towards us fast
    if velocityTowardsUs > 10 and distance < 15 then
        return true, timeToImpact
    end
    
    -- Weapon is very close
    if distance < 6 then
        return true, 0
    end
    
    return false, timeToImpact
end

-- Check if enemy is in attack animation
local function isInAttackAnimation(targetChar)
    local hum = targetChar:FindFirstChild("Humanoid")
    if not hum then return false, 0 end
    
    local animator = hum:FindFirstChildOfClass("Animator")
    if not animator then return false, 0 end
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        if track.IsPlaying and track.Speed > 0.3 then
            local name = string.lower(track.Name)
            
            local isAttack = name:find("swing") or name:find("slash") or 
                            name:find("m1") or name:find("attack") or
                            name:find("combo") or name:find("light") or
                            name:find("heavy") or name:find("stab") or
                            name:find("cut") or name:find("strike")
            
            local isNotAttack = name:find("walk") or name:find("run") or 
                               name:find("idle") or name:find("equip")
            
            if isAttack and not isNotAttack then
                local progress = 0
                pcall(function() 
                    progress = track.TimePosition / track.Length 
                end)
                return true, progress
            end
        end
    end
    
    return false, 0
end

-- MAIN PARRY DETECTION
local function isSwinging(targetChar, targetPlayer)
    if not targetChar then return false end
    
    local myHRP = getHRP()
    if not myHRP then return false end
    
    local tHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not tHRP then return false end
    
    local distance = (myHRP.Position - tHRP.Position).Magnitude
    if distance > Settings.parryRange then return false end
    
    -- Get enemy state
    local state = targetPlayer and EnemyAttackStates[targetPlayer]
    
    -- ===================================================
    -- METHOD 1: PREDICTION (Speed + Position + Angle)
    -- Most reliable for frame-perfect parry
    -- ===================================================
    if state and state.isAttacking then
        local timeSinceAttack = tick() - state.attackStartTime
        local swingTime = SWING_TIMING[state.attackType] or SWING_TIMING.default
        
        -- Calculate optimal parry timing based on attack type
        -- Parry window: 30% to 70% of swing animation
        local parryWindowStart = swingTime * 0.3
        local parryWindowEnd = swingTime * 0.7
        
        if timeSinceAttack >= parryWindowStart and timeSinceAttack <= parryWindowEnd then
            -- Verify enemy is facing us
            local lookVector = tHRP.CFrame.LookVector
            local directionToUs = (myHRP.Position - tHRP.Position).Unit
            local facingUs = lookVector:Dot(directionToUs)
            
            if facingUs > 0.5 then
                return true
            end
        end
    end
    
    -- ===================================================
    -- METHOD 2: WEAPON TRAJECTORY (Raycast-style)
    -- ===================================================
    local willHit, timeToImpact = willWeaponHitUs(targetChar, myHRP)
    if willHit and timeToImpact < 0.3 then
        return true
    end
    
    -- ===================================================
    -- METHOD 3: ANIMATION PROGRESS CHECK
    -- ===================================================
    local inAttack, progress = isInAttackAnimation(targetChar)
    if inAttack and progress > 0.2 and progress < 0.6 then
        -- Also check distance - must be in weapon range
        if distance < 12 then
            return true
        end
    end
    
    -- ===================================================
    -- METHOD 4: EMERGENCY - Very close weapon
    -- ===================================================
    local tool = targetChar:FindFirstChildOfClass("Tool")
    if tool then
        for _, part in pairs(tool:GetDescendants()) do
            if part:IsA("BasePart") then
                local partDist = (myHRP.Position - part.Position).Magnitude
                if partDist < 5 then
                    return true
                end
            end
        end
    end
    
    return false
end

local function isApproaching(targetChar)
    local myHRP = getHRP()
    if not (myHRP and targetChar) then return false end
    
    local tHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not tHRP then return false end
    
    local direction = (myHRP.Position - tHRP.Position).Unit
    return direction:Dot(tHRP.Velocity) > 8
end

local function getClosestEnemy()
    local myHRP = getHRP()
    if not myHRP then return nil end
    
    local closest, minDist = nil, Settings.parryRange
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local tHRP = p.Character:FindFirstChild("HumanoidRootPart")
            local tHum = p.Character:FindFirstChild("Humanoid")
            if tHRP and tHum and tHum.Health > 0 then
                local dist = (myHRP.Position - tHRP.Position).Magnitude
                if dist < minDist then
                    if Settings.targetPriority then
                        local hasTool = p.Character:FindFirstChildOfClass("Tool")
                        if hasTool or not closest then
                            minDist = dist
                            closest = p
                        end
                    else
                        minDist = dist
                        closest = p
                    end
                end
            end
        end
    end
    return closest
end

local function doParry()
    if math.random(1, 100) <= Settings.missChance then return end
    
    local delay = gaussRand(Settings.minDelay / 1000, Settings.maxDelay / 1000)
    task.wait(delay)
    
    if keypress then
        keypress(0x46) -- F key
        task.wait(0.03)
        keyrelease(0x46)
    end
    
    lastParry = tick()
    parryCount = parryCount + 1
    parryCountLabel:SetDescription(tostring(parryCount))
    
    -- Track parry stats per player
    if lastTarget then
        ParryStats[lastTarget] = (ParryStats[lastTarget] or 0) + 1
    end
    
    if Settings.autoKick then
        task.wait(0.08)
        if keypress then
            keypress(0x51) -- Q key
            task.wait(0.02)
            keyrelease(0x51)
        end
        comboCount = comboCount + 1
        comboCountLabel:SetDescription(tostring(comboCount))
    end
end

-- MAIN LOOP
local checkCount = 0
RunService.Heartbeat:Connect(function()
    checkCount = checkCount + 1
    if checkCount < 2 then return end
    checkCount = 0
    
    -- Update UI
    statusLabel:SetDescription(Settings.autoParry and "ON" or "OFF")
    
    -- Update ESP
    updateESP()
    
    -- Cooldown check (skip if rage parry)
    if not Settings.rageParry then
        if tick() - lastParry < Settings.parryCooldown then return end
    end
    
    local myHRP = getHRP()
    local myHum = getHum()
    if not (myHRP and myHum and myHum.Health > 0) then return end
    
    -- Reset combo
    if tick() - lastParry > 3 then
        comboCount = 0
        comboCountLabel:SetDescription("0")
    end
    
    -- Auto Parry
    if Settings.autoParry then
        -- Check ALL nearby enemies for swinging
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local tChar = player.Character
                local tHRP = tChar:FindFirstChild("HumanoidRootPart")
                local tHum = tChar:FindFirstChild("Humanoid")
                
                if tHRP and tHum and tHum.Health > 0 then
                    local distance = (myHRP.Position - tHRP.Position).Magnitude
                    
                    if distance <= Settings.parryRange then
                        -- Check if player is attacking using tracked state
                        local swinging = isSwinging(tChar, player)
                        
                        if swinging then
                            lastTarget = player.Name
                            task.spawn(doParry)
                            break -- Parry once per frame
                        end
                    end
                end
            end
        end
    end
end)

-- ANTI RAGDOLL & MISC FEATURES
RunService.Stepped:Connect(function()
    local char = getChar()
    local hum = getHum()
    
    if char and hum then
        -- Anti Ragdoll
        if Settings.antiRagdoll then
            pcall(function()
                hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
            end)
        end
        
        -- No Fall Damage
        if Settings.noFallDamage then
            pcall(function()
                hum:SetStateEnabled(Enum.HumanoidStateType.Freefall, false)
                hum:ChangeState(Enum.HumanoidStateType.Running)
            end)
        end
        
        -- No Clip
        if Settings.noClip then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = false
                end
            end
        end
        
        -- Speed & Jump Boost (persistent)
        if Settings.speedBoost then
            hum.WalkSpeed = Settings.customSpeed or 24
        end
        
        if Settings.jumpBoost then
            hum.JumpPower = Settings.customJump or 70
        end
    end
end)

-- INFINITE STAMINA (Separate loop for Combat Warriors)
-- =====================================================
-- ADVANCED COMBAT FEATURES (Sound Loop & Anti-Parry)
-- =====================================================

local function setupCombatFeatures(player)
    if player == LocalPlayer then return end

    local function onCharacterAdded(char)
        -- Wait for character to load fully
        local tool
        task.spawn(function()
            repeat task.wait(0.5)
            tool = char:FindFirstChildOfClass("Tool")
            until tool or not char.Parent
            
            if not tool then return end
            
            -- Tool Hitbox Detection (Sound Parry)
            local hitboxes = tool:WaitForChild("Hitboxes", 5)
            if hitboxes then
                local hitbox = hitboxes:FindFirstChild("Hitbox") or 
                               hitboxes:FindFirstChild("Weapon1Hitbox") or 
                               hitboxes:FindFirstChild("Weapon2Hitbox")
                               
                if hitbox then
                    hitbox.ChildAdded:Connect(function(child)
                        -- Sound Detection Logic
                        if Settings.autoParry and Settings.soundParry and child:IsA("Sound") then
                            local myChar = LocalPlayer.Character
                            if not myChar then return end
                            
                            local dist = (myChar.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Magnitude
                            if dist <= Settings.parryRange then
                                -- Trigger Parry
                                if not isParrying then
                                    local vim = game:GetService("VirtualInputManager")
                                    vim:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                                    task.wait(0.05)
                                    vim:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                                end
                            end
                        end
                    end)
                end
            end
        end)
        
        -- Anti-Parry (Unequip on enemy shield)
        local shield = char:WaitForChild("SemiTransparentShield", 10)
        if shield then
            shield:GetPropertyChangedSignal("Transparency"):Connect(function()
                -- If shield becomes visible (Transparency < 1) -> Enemy is parrying
                if shield.Transparency < 1 then
                    -- Check if I am attacking or close
                    local myChar = LocalPlayer.Character
                    if not myChar then return end
                    
                    local dist = (myChar.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Magnitude
                    if dist <= Settings.parryRange + 5 then
                        -- UNEQUIP WEAPON TO AVOID STUN
                        local myTool = myChar:FindFirstChildOfClass("Tool")
                        if myTool and myChar:FindFirstChild("Humanoid") then
                            myChar.Humanoid:UnequipTools()
                            
                            -- Re-equip after parry ends (approx 0.5s - 1s)
                            task.delay(0.6, function()
                                if myChar and myChar:FindFirstChild("Humanoid") then
                                    myChar.Humanoid:EquipTool(myTool)
                                end
                            end)
                        end
                    end
                end
            end)
        end
    end

    if player.Character then 
        task.spawn(function() onCharacterAdded(player.Character) end)
    end
    player.CharacterAdded:Connect(onCharacterAdded)
end

-- Hook existing players
for _, p in ipairs(Players:GetPlayers()) do
    setupCombatFeatures(p)
end
Players.PlayerAdded:Connect(setupCombatFeatures)

local ConfigTab = Window:tab{
    Name = "Config",
    Icon = "rbxassetid://6031280882"
}

local configFolder = "HellHub"
local selectedConfig = "default"
local configNameInput = "default"

local function getConfigData()
    return {
        hitboxEnabled = hitboxEnabled,
        hitboxSize = hitboxSize,
        killAuraEnabled = killAuraEnabled,
        killAuraRange = killAuraRange,
        autoGloryEnabled = autoGloryEnabled,
        ghostModeEnabled = ghostModeEnabled,
        ghostYOffset = ghostYOffset,
        spinBotEnabled = spinBotEnabled,
        spinSpeed = spinSpeed,
        blinkEnabled = blinkEnabled,
        blinkDistance = blinkDistance,
        noSlowEnabled = noSlowEnabled,
        autoCollectEnabled = autoCollectEnabled,
        crosshairEnabled = crosshairEnabled,
        Settings = Settings
    }
end

local function applyConfigData(data)
    if data.hitboxEnabled ~= nil then hitboxEnabled = data.hitboxEnabled end
    if data.hitboxSize then hitboxSize = data.hitboxSize end
    if data.killAuraEnabled ~= nil then killAuraEnabled = data.killAuraEnabled end
    if data.killAuraRange then killAuraRange = data.killAuraRange end
    if data.autoGloryEnabled ~= nil then autoGloryEnabled = data.autoGloryEnabled end
    if data.ghostModeEnabled ~= nil then ghostModeEnabled = data.ghostModeEnabled end
    if data.ghostYOffset then ghostYOffset = data.ghostYOffset end
    if data.spinBotEnabled ~= nil then spinBotEnabled = data.spinBotEnabled end
    if data.spinSpeed then spinSpeed = data.spinSpeed end
    if data.blinkEnabled ~= nil then blinkEnabled = data.blinkEnabled end
    if data.blinkDistance then blinkDistance = data.blinkDistance end
    if data.noSlowEnabled ~= nil then noSlowEnabled = data.noSlowEnabled end
    if data.autoCollectEnabled ~= nil then autoCollectEnabled = data.autoCollectEnabled end
    if data.crosshairEnabled ~= nil then crosshairEnabled = data.crosshairEnabled end
    if data.Settings then
        for k, v in pairs(data.Settings) do
            Settings[k] = v
        end
    end
end

local function getConfigList()
    local configs = {"default"}
    pcall(function()
        if isfolder(configFolder) then
            for _, file in pairs(listfiles(configFolder)) do
                local name = file:match("([^/\\]+)%.json$")
                if name and name ~= "default" then
                    table.insert(configs, name)
                end
            end
        end
    end)
    return configs
end

local function saveConfig()
    pcall(function()
        if not isfolder(configFolder) then makefolder(configFolder) end
        local path = configFolder .. "/" .. configNameInput .. ".json"
        local exists = isfile(path)
        
        if exists and configNameInput ~= selectedConfig then
            Library:notification{ Title = "Warning", Text = "Overwriting " .. configNameInput, Duration = 2 }
        end
        
        local data = getConfigData()
        writefile(path, game:GetService("HttpService"):JSONEncode(data))
        selectedConfig = configNameInput
        Library:notification{ Title = "Saved", Text = configNameInput .. " saved successfully!", Duration = 2 }
    end)
end

local function loadConfig()
    pcall(function()
        local path = configFolder .. "/" .. selectedConfig .. ".json"
        if isfile(path) then
            local data = game:GetService("HttpService"):JSONDecode(readfile(path))
            applyConfigData(data)
            Library:notification{ Title = "Loaded", Text = selectedConfig .. " loaded!", Duration = 2 }
        else
            Library:notification{ Title = "Error", Text = "Config not found!", Duration = 2 }
        end
    end)
end

local function deleteConfig()
    pcall(function()
        local path = configFolder .. "/" .. selectedConfig .. ".json"
        if isfile(path) and selectedConfig ~= "default" then
            delfile(path)
            selectedConfig = "default"
            Library:notification{ Title = "Deleted", Text = "Config deleted!", Duration = 2 }
        end
    end)
end

local function exportConfig()
    pcall(function()
        local data = getConfigData()
        local json = game:GetService("HttpService"):JSONEncode(data)
        setclipboard(json)
        Library:notification{ Title = "Exported", Text = "Config copied to clipboard!", Duration = 2 }
    end)
end

local function importConfig()
    pcall(function()
        local clipboard = nil
        pcall(function()
            clipboard = game:GetService("HttpService"):JSONDecode(getclipboard())
        end)
        if clipboard then
            applyConfigData(clipboard)
            Library:notification{ Title = "Imported", Text = "Config loaded from clipboard!", Duration = 2 }
        else
            Library:notification{ Title = "Error", Text = "Invalid config in clipboard!", Duration = 2 }
        end
    end)
end

ConfigTab:textbox{
    Name = "Config Name",
    Default = "default",
    Placeholder = "Enter config name...",
    Description = "Type name then click Save",
    ShowSaveButton = true,
    Callback = function(text)
        if text and text ~= "" then
            configNameInput = text
        end
    end,
    SaveCallback = function(text)
        if text and text ~= "" then
            configNameInput = text
            saveConfig()
        end
    end
}

ConfigTab:dropdown{
    Name = "Select Config",
    Description = "Choose a saved config to load",
    Options = getConfigList(),
    Callback = function(opt) 
        selectedConfig = opt 
        configNameInput = opt
    end
}

ConfigTab:button{ Name = "Load", Description = "Load selected config", Callback = loadConfig }
ConfigTab:button{ Name = "Delete", Description = "Delete selected config", Callback = deleteConfig }
ConfigTab:button{ Name = "Export", Description = "Copy config to clipboard", Callback = exportConfig }
ConfigTab:button{ Name = "Import", Description = "Load config from clipboard", Callback = importConfig }

ConfigTab:button{
    Name = "Destroy Script",
    Description = "Disable all features and unload",
    Callback = function()
        pcall(function()
            hitboxEnabled = false
            killAuraEnabled = false
            autoGloryEnabled = false
            ghostModeEnabled = false
            spinBotEnabled = false
            blinkEnabled = false
            noSlowEnabled = false
            autoCollectEnabled = false
            crosshairEnabled = false
            Settings.autoParry = false
            Settings.espEnabled = false
            Settings.infiniteStamina = false
            Settings.noJumpCooldown = false
            Settings.noDashCooldown = false
            Settings.noFallDamage = false
            Settings.speedBoost = false
            Settings.jumpBoost = false
            bypassEnabled = false
            
            for key, esp in pairs(ESPObjects) do
                pcall(function()
                    if esp.TopBillboard then esp.TopBillboard:Destroy() end
                    if esp.SideBillboard then esp.SideBillboard:Destroy() end
                    if esp.BottomBillboard then esp.BottomBillboard:Destroy() end
                end)
            end
            ESPObjects = {}
            
            if crosshairGui then crosshairGui:Destroy() end
            
            for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
                if gui.Name:find("HellHub") or gui.Name:find("Hell") or gui.Name:find("ESP") or gui.Name:find("Crosshair") then
                    gui:Destroy()
                end
            end
        end)
    end
}

Window:notification{
    Title = "Hell Hub Loaded",
    Text = "Combat Warriors v3.0 - Press Insert to toggle",
    Duration = 5
}

print("[HELL HUB] Combat Warriors script loaded successfully!")

local noSlowEnabled = false
local autoCollectEnabled = false
local reachEnabled = false
local reachMultiplier = 2
local targetLockEnabled = false
local lockedTarget = nil
local crosshairEnabled = false

task.spawn(function()
    while true do
        task.wait(0.05 + math.random() * 0.02)
        if noSlowEnabled then
            pcall(function()
                local char = LocalPlayer.Character
                if char then
                    local hum = char:FindFirstChild("Humanoid")
                    if hum then
                        hum.WalkSpeed = math.max(hum.WalkSpeed, 16)
                    end
                end
            end)
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(0.3 + math.random() * 0.2)
        if autoCollectEnabled then
            pcall(function()
                local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if myRoot then
                    for _, item in pairs(workspace:GetChildren()) do
                        if item:IsA("Tool") or (item:FindFirstChild("Handle") and item:IsA("Model")) then
                            local handle = item:FindFirstChild("Handle") or item:FindFirstChildOfClass("Part")
                            if handle then
                                local dist = (myRoot.Position - handle.Position).Magnitude
                                if dist < 25 then
                                    pcall(function()
                                        firetouchinterest(myRoot, handle, 0)
                                        task.wait(0.05)
                                        firetouchinterest(myRoot, handle, 1)
                                    end)
                                end
                            end
                        end
                    end
                end
            end)
        end
    end
end)

local crosshairGui = nil
local function createCrosshair()
    if crosshairGui then return end
    crosshairGui = Instance.new("ScreenGui")
    crosshairGui.Name = "HellHubCrosshair"
    crosshairGui.Parent = game:GetService("CoreGui")
    crosshairGui.IgnoreGuiInset = true
    
    local center = Instance.new("Frame")
    center.Size = UDim2.new(0, 4, 0, 4)
    center.Position = UDim2.new(0.5, -2, 0.5, -2)
    center.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    center.BorderSizePixel = 0
    center.Parent = crosshairGui
    
    local top = Instance.new("Frame")
    top.Size = UDim2.new(0, 2, 0, 10)
    top.Position = UDim2.new(0.5, -1, 0.5, -15)
    top.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    top.BorderSizePixel = 1
    top.BorderColor3 = Color3.fromRGB(0, 0, 0)
    top.Parent = crosshairGui
    
    local bottom = Instance.new("Frame")
    bottom.Size = UDim2.new(0, 2, 0, 10)
    bottom.Position = UDim2.new(0.5, -1, 0.5, 5)
    bottom.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    bottom.BorderSizePixel = 1
    bottom.BorderColor3 = Color3.fromRGB(0, 0, 0)
    bottom.Parent = crosshairGui
    
    local left = Instance.new("Frame")
    left.Size = UDim2.new(0, 10, 0, 2)
    left.Position = UDim2.new(0.5, -15, 0.5, -1)
    left.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    left.BorderSizePixel = 1
    left.BorderColor3 = Color3.fromRGB(0, 0, 0)
    left.Parent = crosshairGui
    
    local right = Instance.new("Frame")
    right.Size = UDim2.new(0, 10, 0, 2)
    right.Position = UDim2.new(0.5, 5, 0.5, -1)
    right.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    right.BorderSizePixel = 1
    right.BorderColor3 = Color3.fromRGB(0, 0, 0)
    right.Parent = crosshairGui
end

local function destroyCrosshair()
    if crosshairGui then
        crosshairGui:Destroy()
        crosshairGui = nil
    end
end

CombatTab:toggle{ Name = "No Slow", Description = "Silah tutarken yavaslama", StartingState = false, Callback = function(s) noSlowEnabled = s end }
CombatTab:toggle{ Name = "Auto Collect", Description = "Yerdeki silahlari otomatik topla", StartingState = false, Callback = function(s) autoCollectEnabled = s end }
CombatTab:toggle{ Name = "Crosshair", Description = "Ekranin ortasinda nisangah", StartingState = false, Callback = function(s) 
    crosshairEnabled = s 
    if s then createCrosshair() else destroyCrosshair() end
end }

ConfigTab:toggle{ Name = "Anti-Cheat Bypass", Description = "Remote blocking system", StartingState = true, Callback = function(s) bypassEnabled = s end }

print("[HELL HUB] Extra features loaded!")
